<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | Chasing Rabbits]]></title>
  <link href="http://erickt.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://erickt.github.io/"/>
  <updated>2016-01-27T11:59:27-08:00</updated>
  <id>http://erickt.github.io/</id>
  <author>
    <name><![CDATA[Erick Tryzelaar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Stateful: A Rust Experimental Syntax Extension for Generators and More]]></title>
    <link href="http://erickt.github.io/blog/2016/01/27/stateful-in-progress-generators/"/>
    <updated>2016-01-27T08:31:27-08:00</updated>
    <id>http://erickt.github.io/blog/2016/01/27/stateful-in-progress-generators</id>
    <content type="html"><![CDATA[<p>AKA: Erick Does More Horrible Things to Rust</p>

<p>Hello internet! It&rsquo;s been too long. Not only are the
<a href="http://www.meetup.com/rust-bay-area">Rust Meetups</a> back up and running, it&rsquo;s
time for me to start back to blogging. For the past couple months, I&rsquo;ve been
working on a new syntax extension that will allow people to create fun and
exciting new control flow mechanisms in stable Rust.  &ldquo;For the love of all that
is sigils, why?!&rdquo;  Well, Because I can.  Sometimes when you stare into the
madness, it stares back into you? Or something like that?</p>

<p>It&rsquo;s called <a href="https://github.com/erickt/stateful">Stateful</a>, which helpfully has
no documentation. Such an innocent name, right?  It&rsquo;s very much in progress
(and mostly broken) implementation of some of the ideas in this and future
posts.  So don&rsquo;t go and think these code snippets are executable just yet :)</p>

<p>Anyway, lets show off <code>Stateful</code> by showing how we can implement
<a href="https://en.wikipedia.org/wiki/Generator_%28computer_programming%29">Generators</a>.
We&rsquo;ve got an <a href="https://github.com/rust-lang/rfcs/issues/388">RFC ticket</a> to
implement them, but wouldn&rsquo;t it be nice to have them sooner?  For those of you
unfamiliar with the concept, Generators are function that can be returned from
multiple times, all while preserving state between those calls.  Basically,
they&rsquo;re just a simpler way to write
<a href="https://doc.rust-lang.org/std/iter/#iterator">Iterators</a>.</p>

<p>Say we wanted to iterate over the numbers 0, 1, and 2.  Today, we would write
an <code>Iterator</code> with something like this:</p>

<pre><code class="rust">struct Iter3(usize);

impl Iter3 {
    fn new() -&gt; Self {
        Iter3(0)
    }
}

impl Iterator for Iter3 {
    fn next(&amp;mut self) -&gt; Option&lt;usize&gt; {
        if self.0 &lt; 3 {
            let i = self.0;
            self.0 += 1;
            Some(i)
        } else {
            None
        }
    }
}

fn main() {
    let iter = Iter3::new();
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
}
</code></pre>

<p>The struct preserves our state across these function calls.  It&rsquo;s a pretty
straightforward implementation, but it does have some amount of boilerplate
code. For large iterator implementations, this state management can get quite
complicated.  Instead, lets see how this same code could be expressed with
something like <code>Stateful</code>:</p>

<pre><code class="rust">#![plugin(stateful)]

#[generator]
fn gen3() -&gt; Iterator&lt;Item=usize&gt; {
    let mut i = 0;
    while i &lt; 3 {
        yield_!(i);
        i += 1;
    }
}
</code></pre>

<p>Where <code>yield_!(i)</code> is some magical control flow mechanism that not only
returned some value <code>Some(i)</code>, but also made sure on the <code>iter.next()</code> would
jump the execution to just after the yield.  At the end of the generator, we&rsquo;d
just return <code>None</code>.  We could simplify this even more by unrolling that loop
into:</p>

<pre><code class="rust">#[generator]
fn gen3_unrolled() -&gt; Iterator&lt;Item=usize&gt; {
    yield_!(0);
    yield_!(1);
    yield_!(2);
}
</code></pre>

<p>The fun part is figuring out how to convert these generators into something
that&rsquo;s roughly equivalent to <code>Iter3</code>.  At it&rsquo;s heart, <code>Iter3</code> really is a
simple state machine, where we save the counter state in the structure before
we &ldquo;yield&rdquo; the value to the caller.  Let&rsquo;s look at what we would generate for
<code>gen3_unrolled</code>.</p>

<p>First, we need some boilerplate, that sets up the state of our generator.  We
don&rsquo;t yet have <a href="https://aturon.github.io/blog/2015/09/28/impl-trait/">impl
trait</a>, so we hide all
our stuff in a module:</p>

<pre><code class="rust">fn gen_unrolled() -&gt; gen_unrolled::Generator {
    gen_unrolled::Generator::new()
}

mod gen3_unrolled {
    pub struct Generator {
        state: State,
    }

    impl Generator {
        pub fn new() -&gt; Self {
            Generator {
                state: State::Enter,
            }
        }
    }

    ...
</code></pre>

<p>We represent our generator&rsquo;s state with an enum.  We have our initial state, a
state per yield, then an exit state:</p>

<pre><code class="rust">    enum State {
        Enter,
        AfterYield0,
        AfterYield1,
        AfterYield2,
        Exit,
    }
</code></pre>

<p>Finally, we have our state machine, and a pretty trivial <code>Iterator</code>
implementation that manages entering and exiting the state machine:</p>

<pre><code class="rust">    impl Iterator for Generator {
        type Item = usize;

        fn next(&amp;mut self) -&gt; Option&lt;usize&gt; {
            let state = mem::replace(&amp;mut self.state, State::Exit);
            let (result, next_state) = advance(state);
            self.state = next_state;
            result
        }
    }

    fn advance(mut state: State) -&gt; (Option&lt;usize&gt;, State) {
        loop {
            state = match state {
                State::Enter =&gt; {
                    return_!(Some(0); State::AfterYield0);
                }
                State::AfterYield0 =&gt; {
                    return_!(Some(1); State::AfterYield1);
                }
                State::AfterYield1 =&gt; {
                    return_!(Some(2); State::AfterYield2);
                }
                State::AfterYield2 =&gt; {
                    goto!(State::Exit);
                }
                State::Exit =&gt; {
                    return_!(None; State::Exit);
                }
            }
        }
    }
}
</code></pre>

<p>We move the current <code>state</code> into <code>advance</code>, then have this <code>loop-match</code> state
machine.  Then there are 2 new control flow constructs:
<code>return_!($expr; $next_state)</code> and our old friend <code>goto!($next_state)</code>.
<code>return_!()</code> returns some value and also sets the position the generator should
resume at, and <code>goto!()</code> just sets the next state without leaving the function.</p>

<p>Here&rsquo;s one way they might be implemented:</p>

<pre><code class="rust">macro_rules! goto {
    ($next_state:expr) =&gt; {
        $state = $next_state;
        continue;
    }
}

macro_rules! return_ {
    ($result: expr; $next_state:expr) =&gt; {
        return ($result, $next_state);
    }
}
</code></pre>

<p>Relatively straightforward transformation, right?  But that&rsquo;s an easy case.
Things start to get a wee bit more complicated when we start thinking about how
we&rsquo;d transform <code>gen3</code>, because it&rsquo;s got both a <code>while</code> loop and a mutable
variable.  Lets see that in action.  I&rsquo;ll leave out the boilerplate code and
just focus on the <code>advance</code> function:</p>

<pre><code class="rust">fn advance(mut state: State) -&gt; (Option&lt;usize&gt;, State) {
    loop {
        match state {
            State::Enter =&gt; {
                let mut i = 0;
                goto!(State::Loop(i));
            }
            State::Loop(mut i) =&gt; {
                if i &lt; 3 {
                    goto!(State::Then(i));
                } else {
                    goto!(State::Else(i));
                }
            }
            State::Then(mut i) =&gt; {
                return_!(Some(i); State::AfterYield(i));
            }
            State::Else(mut i) =&gt; {
                goto!(State::AfterLoop(i));
            }
            State::AfterYield(mut i) =&gt; {
                i += 1;
                goto!(State::Loop(i));
            }
            State::AfterLoop(mut i) =&gt; {
                goto!(State::Exit);
            }
            State::Exit =&gt; {
                return_!(None; State::Exit);
            }
        }
    }
}
</code></pre>

<p>Now things are getting interesting! There are two critical things we can see
off the bat.  First, we need to reify the loops and conditionals into the state
machine, because they affect the control flow.  Second, we need to lift any
variables that are accessed across states into the <code>State</code> enum.</p>

<p>We can also start seeing the complications.  The obvious one is mutable
variables.  We need to somehow thread the information about <code>i</code>&rsquo;s mutability
through each of the states.  This naive implementation would trip over the
<code>#[warn(unused_mut)]</code> lint.  And now you might start to get a sense of the
horror that lies beneath <code>Stateful</code>.</p>

<p>At this point, you might be thinking to yourself, &ldquo;Self, if mutable variables
are going to be complicated, what about copies and moves?&rdquo;  You sound like a
pretty sensible person.  Therein lies madness.  You might want to stop thinking
too deeply on it.  If you can&rsquo;t, maybe you think &ldquo;Wait.
What about Generics?&rdquo; Yep.  &ldquo;Borrows?!&rdquo;  Now I&rsquo;m getting a little worried.
&ldquo;How do you even know what&rsquo;s a variable!?!&rdquo;  Sorry.</p>

<p>Yeah so there are one or two things that might be a tad challenging.</p>

<hr />

<p>So that&rsquo;s <code>Stateful</code>.  It&rsquo;s an experiment to get some real world experience
with these control flow mechanisms that may someday feed into RFCs, and maybe,
just maybe, might get implemented in the compiler.  There&rsquo;s no reason we need
to support everything, which would require us to basically reimplement the
compiler.  Instead, I believe there&rsquo;s a subset of Rust that we <em>can</em> support in
order to start getting real experience now.</p>

<p>Generators area really just the start.  There&rsquo;s a whole host of other things
that really are just other things that, if you just squint at em, are really
just state machines in disguise.  It&rsquo;s quite possible if we can pull
<code>Stateful</code>, we&rsquo;ll also be able to implement things like
<a href="https://en.wikipedia.org/wiki/Coroutine">Coroutines</a>,
<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuations</a>, and
that hot new mechanism all the cool languages are implementing these days,
<a href="https://en.wikipedia.org/wiki/Await">Async/Await</a>.</p>

<p>But that&rsquo;s all for later.  First is to get this to work.  In closing, I leave
you with these wise words.</p>

<blockquote><p>ph&#8217;nglui mglw&#8217;nafh Cthulhu R&#8217;lyeh wgah&#8217;nagl fhtagn.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If You Use Unsafe, You Should Be Using Compiletest]]></title>
    <link href="http://erickt.github.io/blog/2015/09/22/if-you-use-unsafe/"/>
    <updated>2015-09-22T10:58:25-07:00</updated>
    <id>http://erickt.github.io/blog/2015/09/22/if-you-use-unsafe</id>
    <content type="html"><![CDATA[<p>One of the coolest things about the Rust typesystem is that you can use it to
make unsafe bindings safe. Read all about it in the
<a href="https://doc.rust-lang.org/nightly/nomicon/">Rustonomicon</a>. However, it can be
really quite easy to slip in a bug where you&rsquo;re not actually making the
guarantees you think you&rsquo;re making. For example, here&rsquo;s a real bug I made in
the <a href="https://github.com/erickt/rust-zmq">ZeroMQ FFI bindings</a> (which have been
edited for clarity):</p>

<pre><code class="rust">pub struct Socket {
    sock: *mut libc::c_void,
    closed: bool
}

impl Socket {
    pub fn as_poll_item&lt;'a&gt;(&amp;self, events: i16) -&gt; PollItem&lt;'a&gt; { // &lt;- BUG!!!
        PollItem {
            socket: self.sock,
            fd: 0,
            events: events,
            revents: 0,
            marker: PhantomData
        }
    }
}

impl Drop for Socket {
    fn drop(&amp;mut self) {
        unsafe {
            zmq_sys::zmq_close(self.sock);
        }
    }
}

pub struct PollItem&lt;'a&gt; {
    socket: *mut libc::c_void,
    fd: libc::c_int,
    events: i16,
    revents: i16,
    marker: PhantomData&lt;&amp;'a Socket&gt;
}

pub fn poll(items: &amp;mut [PollItem], timeout: i64) -&gt; Result&lt;i32, Error&gt; {
    unsafe {
        let rc = zmq_sys::zmq_poll(
            items.as_mut_ptr() as *mut zmq_sys::zmq_pollitem_t,
            items.len() as c_int,
            timeout as c_long);

        if rc == -1i32 {
            Err(errno_to_error())
        } else {
            Ok(rc as i32)
        }
    }
}
</code></pre>

<p>Here&rsquo;s the bug if you missed my callout:</p>

<pre><code class="rust">    pub fn as_poll_item&lt;'a&gt;(&amp;self, events: i16) -&gt; PollItem&lt;'a&gt; { // &lt;- BUG!!!
</code></pre>

<p>My intention was to tie the lifetime of <code>PollItem&lt;'a&gt;</code> to the lifetime of the
<code>Socket</code>, but because I left out one measly <code>'a</code>, Rust doesn&rsquo;t tie the two
together, and instead is actually using the <code>'static</code> lifetime. This then lets
you do something evil like:</p>

<pre><code>// leak the pointer!
let poll_item = {
        let context = zmq::Context::new();
        let socket = context.socket(zmq::PAIR).unwrap();
        socket.as_poll_item(0)
};

// And use the now uninitialized pointer! Wee! Party like it's C/C++!
poll(&amp;[poll_item], 0).unwrap();
</code></pre>

<p>It&rsquo;s just that easy. Fix is simple, just change the function to use <code>&amp;'a self</code>
and Rust will refuse to compile this snippet. Job well done!</p>

<p>Well, no, not really. Because what was particularly devious about this bug is
that it actually came back. Later on I accidentally reverted <code>&amp;'a self</code> back to
<code>&amp;self</code> because I secretly hate myself. The project and examples still compiled
and ran, but that unitialized dereference was just waiting around to cause a
security vulnerability.</p>

<p>Oops.</p>

<p>Crap.</p>

<p>Making sure Rust actually rejects programs that it ought to be rejecting
<strong>fundamentally important</strong> when writing a library that uses Unsafe Rust.</p>

<p>That&rsquo;s where <a href="https://github.com/laumann/compiletest-rs">compiletest</a> comes in.
It&rsquo;s a testing framework that&rsquo;s been extacted from
<a href="https://github.com/rust-lang/rust">rust-lang/rust</a>
that lets you write these &ldquo;shouldn&rsquo;t-compile&rdquo; tests. Here&rsquo;s how to use it.
First add this to your <code>Cargo.toml</code>. We do a little feature dance because
currently <code>compiletest</code> only runs on nightly:</p>

<pre><code class="toml">...
[features]
unstable = ["compiletest_rs"]
...

[dependencies]
compiletest_rs = { "version = "*", optional = true }
...
</code></pre>

<p>Then, add add a test driver <code>tests/compile-tests.rs</code> (or whatever you want to
name it) that runs the compiletest tests:</p>

<pre><code class="rust">#![cfg(feature = "unstable")]

extern crate compiletest_rs as compiletest;

use std::path::PathBuf;
use std::env::var;

fn run_mode(mode: &amp;'static str) {
    let mut config = compiletest::default_config();

    let cfg_mode = mode.parse().ok().expect("Invalid mode");

    config.target_rustcflags = Some("-L target/debug/ -L target/debug/deps/".to_owned());
    if let Ok(name) = var::&lt;&amp;str&gt;("TESTNAME") {
        let s : String = name.to_owned();
        config.filter = Some(s)
    }
    config.mode = cfg_mode;
    config.src_base = PathBuf::from(format!("tests/{}", mode));

    compiletest::run_tests(&amp;config);
}

#[test]
fn compile_test() {
    run_mode("compile-fail");
}
</code></pre>

<p>Finally, add the test! Here&rsquo;s the one I wrote, <code>tests/compile-fail/no-leaking-poll-items.rs</code>:</p>

<pre><code class="rust">extern crate zmq;

fn main() {
    let mut context = zmq::Context::new();
    let _poll_item = {
        let socket = context.socket(zmq::PAIR).unwrap();
        socket.as_poll_item(0) //~ ERROR error: `socket` does not live long enough
    };
}
</code></pre>

<p>Now you can live in peace with the confidence that this bug won&rsquo;t ever appear again:</p>

<pre><code>% multirust run nightly cargo test --features unstable
     Running target/debug/compile_tests-335c5f56b353961f

running 1 test

running 1 test
test [compile-fail] compile-fail/no-leaking-poll-items.rs ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

test compile_test ... ok
</code></pre>

<p>In summary, use <code>compiletest</code>, and demand it&rsquo;s use from the Unsafe Rust
libraries you use! Otherwise you can never be sure if unsafe and undefined
behavior like this will sneak into your project.</p>

<p>TLDR:</p>

<p><img class="center" src="/images/compiletest-badtime.jpg" title="Bad Time" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serde 0.5.0 - Many Many Changes]]></title>
    <link href="http://erickt.github.io/blog/2015/08/07/serde-0-dot-5-0-many-many-changes/"/>
    <updated>2015-08-07T08:14:22-07:00</updated>
    <id>http://erickt.github.io/blog/2015/08/07/serde-0-dot-5-0-many-many-changes</id>
    <content type="html"><![CDATA[<p>Hello all you beautiful and talented people! I&rsquo;m pleased to announce
<a href="https://github.com/serde-rs/serde">serde</a> 0.5.0. We&rsquo;re bumping the major
(unstable) version number here because there have been a huge amount of
breaking changes in the API. This has been done to better support serialization
formats like <a href="https://github.com/TyOverby/bincode">bincode</a>, which relies on
the <code>Serialize</code>e to hint to the <code>Serializer</code> how to parse the next bytes.
This will enable <a href="https://github.com/servo/servo/pull/6583">Servo</a> to use
bincode for its IPC protocol.</p>

<p>Here are the major changes:</p>

<ul>
<li><code>serde::json</code> was factored out into its own separate crate
<a href="https://crates.io/crates/serde_json">serde_json</a>
  <a href="https://github.com/serde-rs/serde/pull/114">#114</a>.</li>
<li>Added serialization and deserialization type hints.</li>
<li>Renamed many functions to change <code>visit_named_{map,seq}</code> to
  <code>visit_struct</code> and <code>visit_tuple_struct</code>
  <a href="https://github.com/serde-rs/serde/pull/114">#114</a>
<a href="https://github.com/serde-rs/serde/pull/120">#120</a>.</li>
<li>Added hooks to allow serializers to serialize newtype tuple structs without a
wrapper type <a href="https://github.com/serde-rs/serde/pull/121">#121</a>.</li>
<li>Remove <code>_error</code> from <code>de::Error</code>
<a href="https://github.com/serde-rs/serde/pull/129">#129</a>.</li>
<li>Rewrote json parser to not consume the whole stream
<a href="https://github.com/serde-rs/serde/pull/127">#127</a>.</li>
<li>Fixed <code>serde_macros</code> for generating fully generic code
<a href="https://github.com/serde-rs/serde/pull/117">#117</a>.</li>
</ul>


<p>Thank you to everyone that&rsquo;s helped with this release:</p>

<ul>
<li>Craig Brandenburg</li>
<li>Hugo Duncan</li>
<li>Jarred Nicholis</li>
<li>Oliver Schneider</li>
<li>Patrick Walton</li>
<li>Sebastian Thiel</li>
<li>Skylar Lipthay</li>
<li>Thomas Bahn</li>
<li>dswd</li>
</ul>


<h1>Benchmarks</h1>

<p>It&rsquo;s been a bit since we last did some
<a href="https://erickt.github.io/blog/2015/02/16/rewriting-rust-serialization-there-can-be-only-one-serde/">benchmarks</a>,
so here are the latest numbers with these compilers:</p>

<ul>
<li>rustc: 1.4.0-nightly (1181679c8 2015-08-07)</li>
<li>go: version go1.4.2 darwin/amd64</li>
<li>clang: Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn)</li>
</ul>


<p><a href="https://github.com/TyOverby/bincode">bincode</a>&rsquo;s serde support makes its first
appearance, which starts out roughly 1/3 slower at serialization, but about the
same speed at deserialization. I haven&rsquo;t done much optimization, so there&rsquo;s
probably a lot of low hanging fruit.</p>

<p><a href="https://crates.io/crates/serde_json">serde_json</a> saw a good amount of
improvement, mainly from some compiler optimizations in the 1.4 nightly. The
deserializer is slightly slower due to the parser rewrite.</p>

<p><a href="https://github.com/dwrensha/capnproto-rust">capnproto-rust</a>&rsquo;s unpacked format
shows a surprisingly large large serialization improvement, with a 10x
improvement from 4GB/s to 15GB/s. Good job dwrensha!  Deserialization is half
as slow as before though. Perhaps I have a bug in my code?</p>

<p>I&rsquo;ve changed the Rust MessagePack implementation to
<a href="https://github.com/3Hren/msgpack-rust">rmp</a>, which has a wee bit faster
serializer, but deserialization was about the same.</p>

<p>I&rsquo;ve also updated the numbers for Go and C++, but those numbers stayed roughly
the same.</p>

<p>Serialization:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library             </th>
<th> format                     </th>
<th> serialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (unpacked)</strong> </td>
<td> <del>4349</del> <strong>15448</strong>   </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto        </td>
<td> Cap&#8217;n Proto                </td>
<td> 3877                 </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode</strong>         </td>
<td> <strong>Raw</strong>                    </td>
<td> <del>1020</del> <strong>3278</strong>    </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode (serde)</strong> </td>
<td> <strong>Raw</strong>                    </td>
<td> <strong>2143</strong>             </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (packed)</strong>   </td>
<td> <del>583</del> <strong>656</strong>      </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf        </td>
<td> Protocol Buffers           </td>
<td> <del>596</del> 627          </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rmp</strong>             </td>
<td> <strong>MessagePack</strong>            </td>
<td> <del>397</del> <strong>427</strong>      </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rust-protobuf</strong>   </td>
<td> <strong>Protocol Buffers</strong>       </td>
<td> <del>357</del> <strong>373</strong>      </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde::json</strong>     </td>
<td> <strong>JSON</strong>                   </td>
<td> <del>288</del> <strong>337</strong>      </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson           </td>
<td> JSON                       </td>
<td> 307                  </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf          </td>
<td> Protocol Buffers           </td>
<td> <del>214</del> 226          </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serialize::json</strong> </td>
<td> <strong>JSON</strong>                   </td>
<td> <del>147</del> <strong>212</strong>      </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson              </td>
<td> JSON                       </td>
<td> 147                  </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json       </td>
<td> JSON                       </td>
<td> 85                   </td>
</tr>
</tbody>
</table>


<p>Deserialization:</p>

<table>
<thead>
<tr>
<th> language </th>
<th> library             </th>
<th> format                     </th>
<th> deserialization (MB/s) </th>
</tr>
</thead>
<tbody>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (unpacked)</strong> </td>
<td> <del>2185</del> <strong>1306</strong>      </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto        </td>
<td> Cap&#8217;n Proto (zero copy)    </td>
<td> 1407                   </td>
</tr>
<tr>
<td> Go       </td>
<td> go-capnproto        </td>
<td> Cap&#8217;n Proto                </td>
<td> 711                    </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>capnproto-rust</strong>  </td>
<td> <strong>Cap&#8217;n Proto (packed)</strong>   </td>
<td> <del>351</del> <strong>464</strong>        </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode (serde)</strong> </td>
<td> <strong>Raw</strong>                    </td>
<td> <strong>310</strong>                </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>bincode</strong>         </td>
<td> <strong>Raw</strong>                    </td>
<td> <del>142</del> <strong>291</strong>        </td>
</tr>
<tr>
<td> Go       </td>
<td> gogoprotobuf        </td>
<td> Protocol Buffers           </td>
<td> 270                    </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson           </td>
<td> JSON (sax)                 </td>
<td> 182                    </td>
</tr>
<tr>
<td> C++      </td>
<td> rapidjson           </td>
<td> JSON (dom)                 </td>
<td> 155                    </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rust-protobuf</strong>   </td>
<td> <strong>Protocol Buffers</strong>       </td>
<td> <strong>143</strong>                </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>rmp</strong>             </td>
<td> <strong>MessagePack</strong>            </td>
<td> <del>138</del> <strong>128</strong>        </td>
</tr>
<tr>
<td> <strong>Rust</strong> </td>
<td> <strong>serde::json</strong>     </td>
<td> <strong>JSON</strong>                   </td>
<td> <del>140</del> <strong>122</strong>        </td>
</tr>
<tr>
<td> Go       </td>
<td> ffjson              </td>
<td> JSON                       </td>
<td> 95                     </td>
</tr>
<tr>
<td> Go       </td>
<td> goprotobuf          </td>
<td> Protocol Buffers           </td>
<td> 81                     </td>
</tr>
<tr>
<td> Go       </td>
<td> encoding/json       </td>
<td> JSON                       </td>
<td> 23                     </td>
</tr>
<tr>
<td> Rust     </td>
<td> serialize::json     </td>
<td> JSON                       </td>
<td> 23                     </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serde 0.4.0 - Syntax Extensions in Stable Rust and More!]]></title>
    <link href="http://erickt.github.io/blog/2015/05/18/serde-0-dot-4-0-now-supports-macros-in-stable-rust/"/>
    <updated>2015-05-18T07:57:19-07:00</updated>
    <id>http://erickt.github.io/blog/2015/05/18/serde-0-dot-4-0-now-supports-macros-in-stable-rust</id>
    <content type="html"><![CDATA[<p>Hello Internet! I&rsquo;m pleased to announce
<a href="https://github.com/serde-rs/serde">serde</a> 0.4.0, which now supports many new
features with help from our growing serde community. The largest is now serde
supports syntax extensions in stable Rust by way of
<a href="https://github.com/erickt/rust-syntex">syntex</a>. syntex is a fork of Rust&rsquo;s
parser library libsyntax that has been modified to enable code generation.
serde uses it along with a
<a href="http://doc.crates.io/build-script.html">Cargo build script</a> to expand the
<code>#[derive(Serialize, Deserialize)]</code> decorator annotations. Here&rsquo;s how to use
it.</p>

<p>First, lets start with a simple serde 0.3.x project that&rsquo;s forced to use
nightly because it uses <code>serde_macros</code>. The <code>Cargo.toml</code> is:</p>

<pre><code class="toml">[package]
name = "hello_world"
versio = "0.1.0"
authors = ["Erick Tryzelaar &lt;erick.tryzelaar@gmail.com&gt;"]
license = "MIT/Apache-2.0"

[dependencies]
serde = "*"
serde_macros = "*"
</code></pre>

<p>And the actual library is <code>src/lib.rs</code>:</p>

<pre><code class="rust">#![feature(custom_derive, plugin)]
#![plugin(serde_macros)]

extern crate serde;

#[derive(Serialize, Deserialize)]
pub struct Point {
    x: u32,
    y: u32,
}
</code></pre>

<p>In order to use Stable Rust, we can use the new <code>serde_codegen</code>. Our strategy
is to split our input into two files. The first is the entry point Cargo will
use to compile the library, <code>src/lib.rs</code>. The second is a template that
contains the macros, <code>src/lib.rs.in</code>. It will be expanded into
<code>$OUT_DIR/lib.rs</code>, which is included in <code>src/lib.rs</code>. So <code>src/lib.rs</code> looks
like:</p>

<pre><code class="rust">extern crate serde;

include!(concat!(env!("OUT_DIR"), "/lib.rs"));
</code></pre>

<p><code>src/lib.rs.in</code> then just looks like:</p>

<pre><code class="rust">#[derive(Serialize, Deserialize)]
pub struct Point {
    x: u32,
    y: u32,
}
</code></pre>

<p>In order to generate the <code>$OUT_DIR/lib.rs</code>, we&rsquo;ll use a Cargo build script.
We&rsquo;ll configure <code>Cargo.toml</code> with:</p>

<pre><code class="toml">[package]
name = "hello_world"
versio = "0.1.0"
authors = ["Erick Tryzelaar &lt;erick.tryzelaar@gmail.com&gt;"]
license = "MIT/Apache-2.0"
build = "build.rs"

[build-dependencies]
syntex = "*"
serde_codegen = "*"

[dependencies]
serde = "*"
</code></pre>

<p>Finally, the <code>build.rs</code> script itself uses <code>syntex</code> to expand the syntax
extensions:</p>

<pre><code class="rust">extern crate syntex;
extern crate serde_codegen;

use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();

    let src = Path::new("src/lib.rs.in");
    let dst = Path::new(&amp;out_dir).join("lib.rs");

    let mut registry = syntex::Registry::new();

    serde_codegen::register(&amp;mut registry);
    registry.expand("", &amp;src, &amp;dst).unwrap();
}
</code></pre>

<h2>Downside 1: Error Locations</h2>

<p>While <code>syntex</code> is quite powerful, there are a few major downsides. Rust does
not yet support the ability for a generated file to provide error location
information from a template file. This means that tracking down errors requires
manually looking at the generated code and trying to identify where the error
in the template. However, there is a workaround.  It&rsquo;s actually not that
difficult to support <code>syntex</code> and the Rust Nightly compiler plugins. To update
our example, we&rsquo;ll change the <code>Cargo.toml</code> to:</p>

<pre><code class="toml">[package]
name = "hello_world"
versio = "0.1.0"
authors = ["Erick Tryzelaar &lt;erick.tryzelaar@gmail.com&gt;"]
license = "MIT/Apache-2.0"
build = "build.rs"

[features]
default = ["with_syntex"]
nightly = ["serde_macros"]
with_syntex = ["serde", "serde_codegen"]

[build-dependencies]
syntex = { version = "*", optional = true }
serde_codegen = { version = "*", optional = true }

[dependencies]
serde = "*"
serde_macros = { version = "*", optional = true }
</code></pre>

<p>Then the <code>build.rs</code> is changed to optionally expand the macros in our template:</p>

<pre><code class="rust">#[cfg(feature = "with_syntex")]
mod inner {
    extern crate syntex;
    extern crate serde_codegen;

    use std::env;
    use std::path::Path;

    pub fn main() {
        let out_dir = env::var_os("OUT_DIR").unwrap();

        let src = Path::new("src/lib.rs.in");
        let dst = Path::new(&amp;out_dir).join("lib.rs");

        let mut registry = syntex::Registry::new();

        serde_codegen::register(&amp;mut registry);
        registry.expand("", &amp;src, &amp;dst).unwrap();
    }
}

#[cfg(not(feature = "with_syntex"))]
mod inner {
    pub fn main() {}
}

pub fn main() {
    inner::main()
}
</code></pre>

<p>Finally, <code>src/lib.rs</code> is updated to:</p>

<pre><code class="rust">#![cfg_attr(feature = "nightly", feature(plugin))]
#![cfg_attr(feature = "nightly", plugin(serde_macros))]

extern crate serde;

#[cfg(feature = "nightly")]
include!("lib.rs.in");

#[cfg(feature = "with_syntex")]
include!(concat!(env!("OUT_DIR"), "/lib.rs"));
</code></pre>

<p>Then most development can happen with using the Nightly Rust and
<code>cargo build --no-default-features --features nightly</code> for better error
messages, but downstream consumers can use Stable Rust without worry.</p>

<h2>Downside 2: Macros in Macros</h2>

<p>Syntex can only expand macros inside macros it knows about, and it doesn&rsquo;t know
about the builtin macros. This is because a lot of the stable macros are using
unstable features under the covers. So unfortunately if you&rsquo;re using a library
like the quasiquoting library <a href="https://github.com/erickt/rust-quasi">quasi</a>,
you cannot write:</p>

<pre><code class="rust">let exprs = vec![quote_expr!(cx, 1 + 2)];
</code></pre>

<p>Instead you have to pull out the syntex macros into a separate variable:</p>

<pre><code class="rust">let expr = quote_expr!(cx, 1 + 1);
let exprs = vec![expr];
</code></pre>

<h2>Downside 3: Compile Times</h2>

<p>Syntex can take a while to compile. It may be possible to optimize this, but
that may be difficult while keeping compatibility with <code>libsyntax</code>.</p>

<hr />

<p>That&rsquo;s <code>v0.4.0</code>. I hope you enjoy it! Please let me know if you run into any
<a href="https://github.com/serde-rs/serde/issues">problems</a>.</p>

<h2>Release Notes</h2>

<p>Here are other things that came with this version:</p>

<ul>
<li>Added field annotation to enable renaming fields for different backends
<a href="https://github.com/serde-rs/serde/pull/69">#69</a>. For example:</li>
</ul>


<pre><code class="rust">struct Point {
  #[serde(rename="X")]
  x: u32,

  #[serde(rename(json="the-x", xml="X")]
  y: u32,
}
</code></pre>

<ul>
<li>Faster JSON string parsing <a href="https://github.com/serde-rs/serde/pull/71">#71</a>.</li>
<li>Add a <code>LineColIterator</code> that tracks line and column information for
  deserializers <a href="https://github.com/serde-rs/serde/pull/58">#58</a>.</li>
<li>Improved bytestring support <a href="https://github.com/serde-rs/serde/pull/72">#72</a></li>
<li>Changed <code>de::PrimitiveVisitor</code> to also depend on <code>FromStr</code>
<a href="https://github.com/serde-rs/serde/pull/70">#70</a></li>
<li>Added impls for fixed sized arrays with 1 to 32 elements
<a href="https://github.com/serde-rs/serde/pull/74">#74</a></li>
<li>Added <code>json::Value::lookup</code>, that allows values to be extracted with
<code>value.lookup("foo.bar.baz")</code> <a href="https://github.com/serde-rs/serde/pull/76">#76</a></li>
</ul>


<p>Bug Fixes:</p>

<ul>
<li>Make sure that -0.0 gets serialized as &ldquo;-0.0&rdquo;
<a href="https://github.com/serde-rs/serde/commit/f0c87fb">f0c87fb</a>.</li>
<li>Missing field errors displayed original field name instead of renamed
<a href="https://github.com/serde-rs/serde/pull/64">#64</a>.</li>
<li>Fixed handling json integer overflow</li>
</ul>


<p>A special thanks to everyone that helped with this release:</p>

<ul>
<li>Alex Crichton</li>
<li>Andrew Poelstra</li>
<li>Corey Farwell</li>
<li>Hugo Duncan</li>
<li>Jorge Israel Pe√±a</li>
<li>Kang Seonghoon</li>
<li>Mikhail Borisov</li>
<li>Oliver Schneider</li>
<li>Sebastian Thiel</li>
<li>Steven Fackler</li>
<li>Thomas Bahn</li>
<li>derhaskell</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serde 0.3.1 - Now Compatible With Beta! Plus Aster and Quasi Updates]]></title>
    <link href="http://erickt.github.io/blog/2015/04/12/serde-0-dot-3-1-now-compatible-with-beta/"/>
    <updated>2015-04-12T11:53:43-07:00</updated>
    <id>http://erickt.github.io/blog/2015/04/12/serde-0-dot-3-1-now-compatible-with-beta</id>
    <content type="html"><![CDATA[<p>I just pushed up <a href="https://github.com/erickt/rust-serde">serde</a> 0.3.1 to
<a href="https://crates.io/crates/serde">crates.io</a>, which is now compatible with beta!
serde_macros 0.3.1, however still requires nightly.  But this means that if
you implement the all the traits using stable features, then any users of serde
should work with rust 1.0.</p>

<p>Here&rsquo;s what&rsquo;s also new in serde v0.3.1:</p>

<ul>
<li>Renamed <code>ValueDeserializer::deserializer</code> into <code>ValueDeserializer::into_deserializer</code>.</li>
<li>Renamed the attribute that changes the name a field is serialized
<code>#[serde(alias="...")]</code> to <code>#[serde(rename="...")]</code>.</li>
<li>Added implementations for <code>Box</code>, <code>Rc</code>, and <code>Arc</code>.</li>
<li>Updated <code>VariantVisitor</code> to hint to the deserializer which variant kind it is expecting.
This allows serializers to serialize a unit variant as a string.</li>
<li>Added an <code>Error::unknown_field_error</code> error message.</li>
<li>Progress on the documentation, but there&rsquo;s still plenty more to go.</li>
</ul>


<p>Upstream of serde, I&rsquo;ve been also doing some work on
<a href="https://github.com/erickt/rust-aster">aster</a> and
<a href="https://github.com/erickt/rust-quasi">quasi</a>, which are my helper libraries to
simplify writing syntax extensions.</p>

<p>aster v0.2.0:</p>

<ul>
<li>Added builders for qualified paths, slices, <code>Vec</code>, <code>Box</code>, <code>Rc</code>, and <code>Arc</code>.</li>
<li>Extended item builders to support <code>use</code> simple paths, globs, and lists.</li>
<li>Added a helper for building the <code>#[automatically_derived]</code> annotation.</li>
</ul>


<p>quasi v0.1.9:</p>

<ul>
<li>Backported support for <code>quote_attr!()</code> and <code>quote_matchers!()</code> from <code>libsyntax</code>.</li>
<li>Added support for unquoting arbitrary slices.</li>
</ul>


<p>Thanks for everyone&rsquo;s help with this release!</p>
]]></content>
  </entry>
  
</feed>
